### Animyoji

## ðŸŽ¬ Demo Preview

[![Animyoji Demo](https://img.youtube.com/vi/bj4AzTbcWu8/maxresdefault.jpg)](https://youtube.com/shorts/bj4AzTbcWu8)

> **[ðŸ“± Watch the app demo on YouTube Shorts](https://youtube.com/shorts/bj4AzTbcWu8)**

Anime streaming app (prototype) built with Flutter, following a pragmatic Clean Architecture layout.
The goal is to keep UI lean, prepare a domain-centered core, and isolate data/model concerns for
future scaling to real APIs.

+

---

+

## Architecture Overview

+

This project adopts a layered architecture inspired by Clean Architecture:

+

- **Presentation (UI)**: Widgets, pages, navigation, and theming.
- **Domain**: Enterprise rules â€” entities, repository contracts, and use cases. Currently scaffolded
  for future growth.
- **Data**: Models and data sources. In this prototype, in-memory mocks stand in for remote/local
  sources.
- **Helpers/Core**: Cross-cutting utilities and extensions.
- **Generated**: Code generated by tools (e.g., `flutter_gen`) for type-safe assets.

+

Dependency rule (intended end-state):

- **Presentation â†’ Domain** (can use Helpers)
- **Data â†’ Domain**
- **Domain** depends on nothing (pure Dart)

Note: During prototyping, `presentation` reads mock data directly from `data` to ship UI quickly.
This is a deliberate, temporary deviation to be refactored once real repositories/use cases are
introduced.

---

## Folder Structure

```
lib/
  data/
    fake_data/                 # In-memory mock data used by the UI (prototype only)
    models/                    # DTOs/Models with fromJson factory constructors
  domain/                      # Reserved for entities, repositories, use cases (currently empty)
  helpers/
    extensions/                # UI/productivity extensions (padding, taps, formatting)
  presentation/
    ui/
      pages/                   # Screens: splash, home, details, plans
      widgets/                 # Reusable UI components
  gen/                         # Generated code (e.g., Assets via flutter_gen)
```

Assets live under `assets/images/` and `assets/icons/`, configured in `pubspec.yaml`. Launcher icon
and splash are configured via `flutter_launcher_icons` and `flutter_native_splash`.

---

## Layer-by-Layer Details (Top â†’ Bottom)

### Presentation Layer

- Location: `lib/presentation/ui/`
- Contents: `pages` (e.g., `home_page.dart`, `series_details_page.dart`, `plan_page.dart`,
  `splash_page.dart`) and `widgets` (e.g., `series_card.dart`, `plan_card.dart`, `nav_bar.dart`).
- State management: Local `StatefulWidget` with `setState` for simple view state. No global state
  library yet; can scale to Provider/Riverpod/BLoC later.
- Navigation: `Navigator` with `MaterialPageRoute` and a small custom route (
  `custom_plan_page_route.dart`) for transitions.
- Theming/UX: `google_fonts` for typography; custom chips/buttons; `sliver_tools` used for complex
  details layout.

Design decisions:

- Keep widgets pure and small; move formatting and spacing into extensions for readability.
- Use composition via reusable widgets (`series_card`, `character_card`, `category_chip`) to keep
  pages declarative.
- Defer complex routing/state decisions until real data and flows arrive.

### Domain Layer

- Location: `lib/domain/`
- Purpose: Define business rules that persist regardless of UI or data source.
- Will contain:
    - Entities (pure Dart models reflecting core concepts)
    - Repository interfaces (contracts the data layer must fulfill)
    - Use cases (application-specific operations orchestrating repositories)

Current status: Empty scaffolding. This keeps the door open to introduce API-backed features without
reshaping the UI.

### Data Layer

- Location: `lib/data/`
- Contents:
    - `models/`: `SeriesModel`, `CharacterModel`, `PlanModel`, `SeriesStatistics` â€” simple DTOs with
      `fromJson` factories.
    - `fake_data/`: `getMockSeries()`, `getMockCharacters()`, `getMockPlans()` used by the UI during
      prototyping.
- Future: Add `datasources/` (remote via REST/GraphQL, local via cache/DB) and `repositories/`
  implementing domain contracts, mapping DTOs â†” entities.

Design decisions:

- Keep models small and explicit to avoid dynamic maps leaking into UI.
- Use `flutter_gen` for asset paths to avoid stringly-typed errors in mocks.

### Helpers/Core

- Location: `lib/helpers/`
- Extensions:
    - `padding_extensions.dart`: Fluent padding/sliver-padding helpers for readable layout code.
    - `widget_extensions.dart`: `onTap` wrapper for any widget.
    - `int_extensions.dart`, `num_extensions.dart`: `height`/`width` gaps and number utilities.
    - `numerical_format_extention.dart`: Compact number formatting (K/M/B) via a simple strategy
      chain.

Design decisions:

- Prefer readable layout DSL-like extensions over nested `Padding` widgets.
- Keep helpers UI-agnostic where possible.

### Generated Code

- Location: `lib/gen/`
- Tools: `flutter_gen` configured in `pubspec.yaml` for type-safe `Assets` access.
- Rationale: Avoid hardcoded strings/paths; enable IDE autocomplete and safer refactors.

---

## Current Trade-offs (Prototype Phase)

- The `presentation` layer directly imports from `data/fake_data` to bootstrap UI quickly.
- No DI container yet. Once domain/data mature, introduce `get_it` or Riverpod for dependency
  wiring.
- No global state solution. Evaluate needs after integrating real data and flows.

Planned refactor path:

1. Define domain entities and repository interfaces in `lib/domain/`.
2. Implement repositories in `lib/data/` with real datasources.
3. Introduce use cases and inject them into UI via DI.
4. Replace direct `fake_data` usage in pages with use case calls.

---

## Tech Stack

- Flutter (Material 3 theming)
- Packages: `google_fonts`, `flutter_svg`, `sliver_tools`, `flutter_gen_runner`,
  `flutter_native_splash`, `flutter_launcher_icons`

---

## How to Extend a Feature (Example: Series List)

- Domain: Create `Series` entity and `SeriesRepository` contract with `fetchSeries()`.
- Data: Implement `SeriesRepositoryImpl` backed by `RemoteSeriesDataSource` (and optional
  `LocalSeriesCache`). Map DTOs to entities.
- Presentation: Inject a `FetchSeriesUseCase` into `HomePage` (via constructor/Provider). Render
  states (loading/success/error).

This keeps UI stable even if data sources change.

---

## Run

- Ensure Flutter SDK is installed.
- Fetch deps and run:

```bash
flutter pub get
flutter run
```

---

+

## Notes

- This README documents the intended Clean Architecture for the whole app and explains current
  prototype shortcuts. As real data and features arrive, refactor along the dependency rules
  outlined above.
